# Python基础教程  
## 第1章 基础知识  
###  1.1 安装Python  
#### 1.1.1 Windows  
打开浏览器，访问 http://www.python.org 下载对应版本安装包  
#### 1.1.2 Linux和Unix  
在大多数的Linux和Unix的系统安装中，Python的解释器就已经存在了；可在终端中输入python字符串来检验是否已经安装python  
#### 1.1.3 苹果机（Macintosh）  
苹果机系统自带Python，同Linux系统一致，可通过在终端中输入python字符串来检验是否安装python  
#### 1.1.4 其他发布版  
在标准版之外，还有很多python的其他版本；最有名的是ActivePython。  
#### 1.1.5 时常关注，保持更新  
Python语言还在不断发展。
###  1.2 交互式解释器  

###  1.3 算法是什么  
算法也就是计算机程序即告诉计算机做什么事
###  1.4 数字和表达式  
交互式Python解释器可以当作强大的计算器使用  
#### 1.4.1 长整型数  
普通整数的绝对值不能大于2147483647；若需要数字的绝对值大于2147483647，则可以使用长整型数；长整型数书写方法和普通整数一样，但结尾有个L（用小写l也可以，单l和1太像了，建议用大写L）  
#### 1.4.2 十六进制和八进制  

###  1.5 变量  
变量是代表（或者引用）某值的名字，在使用变量之前，要对变量赋值；  
变量命名规范：包括字母、数字及下划线（_）；不能用数字开头
e.g x = 3  
###  1.6 语句  
表达式是某事  
语句是做某事   
语句特性：即改变了事物；赋值语句改变了变量，print语句改变了屏幕显示的内容。
###  1.7 获取用户输入
> input(“The meaning of life：”) 
 
###  1.8 函数  
函数就像是用来实现特定功能的小程序一样，可以用函数来替代运算符。  
e.g 2**3 = 8  
pow(2,3) = 8  
当然了，也可以自己定义函数，加以复用。  
使用函数的方式称之为调用函数，可以通过提供参数，函数会给出对应的返回值给到用户。  
### 1.9 模块  
模块即是被导入到python以增强其功能的扩展，需要使用特殊的import命令来导入模块。  
> import math
> math.floor(32.9)

用import导入了模块，然后按照“模块.函数”的格式使用这个模块的函数。  
使用“from 模块 import 函数”这种形式的import命令之后，就可以直接使用函数了，而不需要模块名作为前缀。   
#### 1.9.1 cmath和复数  
 sqrt函数用于计算一个数的平方根，如果将一个负数作为参数传递给sqrt函数，会提示ValueError。  
 负数的平方根是虚数，可由另外一个叫做cmath的模块来实现这些功能--求负数的平方根。  
#### 1.9.2 回到_future_  

### 1.10 保存并执行程序  
交互式解释器是Python的强项之一，它让实时检验解决方案以及体验这门语言成为了现实。但是在交互式解释器里面输入的一切都会在交互式解释器退出时消失。而我们真正想做的事情是编写自己和他人都能运行的程序。  
首先，需要一个文本编辑器，最好是专门用来编程的；编写完成后，保存文件；再次打开刚刚保存的文件，运行这个文件，则在解释器窗口打印出来刚刚这个文件的内容。  
#### 1.10.1 通过命令提示符运行Python脚本  
在DOS窗口或者UNIX的Shell窗口中可通过执行python 文件.py来运行Python脚本。  
PS：注意文件路径以及文件后缀是否为py  
#### 1.10.2 让脚本像普通程序一样运行  
希望像运行其他程序一样的运行Python脚本，而不需要Python的解释器。  
在UNIX中有个标准的实现方法，即在脚本首行前面加上#!(叫做pound bang)，在其后面加上用于解释脚本的程序的绝对路径。  
e.g #!/Users/lihongying/anaconda3/bin/python  
本机python的绝对路径(使用which python命令查看)
不管Python的二进制文件在哪里，程序都会自动执行。  
chmod +x XXX.py  
#### 1.10.3 注释  
“#”号在Python中有特殊作用，在输入它的时候，它右边的一切都会被忽略。  
单行注释：“#”  
多行注释：以”###“开始和结束  
### 1.11 字符串  
字符串在几乎所有真实可用的Python程序中都会存在，并且有多种用法，最重要的用法就是表示一些文本。  
#### 1.11.1 单引号字符串和转义引号  
字符串是值，就像数字一样；   
字符串是由单引号或者双引号引起来的；  
若在字符串中间使用了单引号/双引号，那么在外层则应使用双引号/单引号；或者使用反斜线(\)对字符串中使用到的引号进行转义。  
#### 1.11.2 拼接字符串  
拼接字符串就像进行加法运算一样。  
e.g print("Hello" + "World!")  
#### 1.11.3 字符串表示，str和repr  
通过Python打印的字符串还是被引号引起来的，这是因为Python打印值的时候回保持该值在Python代码中的状态。  
使用print语句打印字符串时，则直接打印出字符串。  
值被转换为字符串有两种机制：  
str：会把值转换成合理形式的字符串，以便用户理解；  
repr：会创建一个字符串，以合法的Python表达式的形式来表示值。  
repr(x)的功能也可以用`x`(反引号)实现；在打印包含数字的句子中非常有用。  
#### 1.11.4 input和raw_input的比较  
input：假设用户输入的是合法的Python表达式
raw_input：会把用户的所有输入当作原始数据，然后将其放在字符串中  
#### 1.11.5 长字符串、原始字符串和Unicode  
1.长字符串  
如果需要写一个非常长的字符串，它需要跨很多行，那么可以使用三个引号代替普通引号（单/双引号均可）  
PS：在这种引用方式中，可以同时使用单引号和双引号(无需转义)  
2.原始字符串  
原始字符串不会把反斜线当作是特殊字符；即不能在原始字符串中使用反斜线；  
原始字符串以r开头；  
3.Unicode字符串  
字符串常量的最后一种类型就是Unicode字符串（或者称之为Unicode对象）。  
Python中的普通字符串在内部是以8位的ASCII码形成存储的，而Unicode字符串则存储为16位的Unicode字符；  
Unicode字符串使用u为前缀。
### 1.12 小结  
## 第2章 列表和元组  
本章引入新的概念：数据结构。数据结构是通过某种方式组织在一起的数据元素的集合，数据元素可以使数字或者字符，甚至可以使其他数据结构。  
在Python中最基本的数据结构是序列，序列中每个元素被分配一个序号，即元素的位置，也称之为索引，索引号从0开始计算，以此类推。
### 2.1 序列概览  
Python包含6种内建序列，分别是列表、元组、字符串、Unicode字符串、buffer对象和xrange对象。本章重点讨论最常用的两种类型：列表和元组。  
列表和元组最主要的区别就是列表可以修改，元组不可以。  
Python中还有一种名为容器的数据结构，容器基本上是包含其他对象的任意对象，序列和映射是两类主要的容器。
### 2.2 通用序列操作  
所有序列类型都可以进行某些特定的操作，这些操作包括索引、分片(切片)、加、乘以及检查某个元素是否属于序列的成员（成员资格）。除此之外，Python还有计算序列长度、找出最大和最小元素的内建函数。  
PS：上述内容中并未涉及序列的迭代操作；迭代--即对序列中的每个元素重复执行某些操作。  
#### 2.2.1 索引  
序列中的每个元素都是有编号的--从0开始递增。序列中的元素可以通过编号访问。使用负数索引时，Python会从右边，也就是最后一个元素开始计数，最后一个元素的位置编号为-1。  
#### 2.2.2 分片  
与使用索引来访问单个元素类似，可以使用分片操作来访问一定范围内的元素；分片通过冒号相隔的两个索引实现，用数学思维描述就是[左闭右开区间)  
1.优雅的捷径  
访问一个序列中最后3个元素，有两种表示方法；一种是显式操作，即：序列名称[n-3:n]；第二种是捷径，即：序列名称[-3:]。  
PS：这种捷径同样适用于序列开始的元素。  
如果需要整个序列，则将两个索引号置空，中间留着冒号即可。  
e.g 序列[:] = 序列  
2.更大的步长  
进行分片的时候，分片的开始和结束点都需要指定，另外一个参数’步长‘通常是隐式设置的，默认为1。  
e.g 序列[3:10:2]  
取出序列中从第3个元素开始，步长为2的元素，直至第10个元素。  
PS：步长可以为负数，即从右到左提取元素  
#### 2.2.3 序列相加  
使用加号（+）可以进行序列的连接操作。  
PS：两种相同类型的序列才可以相加
#### 2.2.4 乘法  
用数字x乘以一个序列会生成新的序列，新序列中，原序列会被重复x次。  
None、空列表和初始化  
空列表可以简单地通过两个中括号进行表示[]；如果想要创建一个十个元素的空间，却不包含任何有用内容的列表，可以使用[None] * 10 来表示；  
PS：None是Python的内建值，代表什么也没有  
#### 2.2.5 成员资格  
为了检查一个值是否在序列中，可以使用in运算符，该运算符检查某个条件是否为真，然后返回相应的值，条件为真返回True，条件为假返回False；该运算符叫做布尔运算符，真值叫做布尔值。  
#### 2.2.6 长度、最小值和最大值  
内建函数len、min、max非常有用：  
len函数返回序列中所包含元素的数量；  
min函数和max函数则分别返回序列中最大和最小的元素。
### 2.3 列表：Python的“苦力”  
列表是可变的(mutable)--可以改变列表的内容，并且列表有很多有用的、专门的方法。  
#### 2.3.1 list函数  
因为字符串不能像列表一样被修改，所以有时根据字符串创建列表会很有用。  
list函数可以根据字符串创建一个新的列表。  
PS：list函数适用于所有类型的序列
#### 2.3.2 基本的列表操作  
列表可以使用所有适用于序列的标准操作，例如索引、分片、连接和乘法。与此同时，列表是可以修改的，本节会介绍一些可以改变列表的方法：元素赋值、元素删除、分片赋值以及列表方法。  
1.改变列表：元素赋值  
使用普通的赋值语句可以改变列表。  
e.g x[1] = 2  
2.删除元素  
使用del语句来删除列表中的元素。  
e.g del x[1]  
3.分片赋值  
分片是一个强大的特性，分片赋值操作则更能体现它的强大。分片赋值语句可以在不需要替换任何原有元素的情况下插入新的元素；通过分片赋值语句来删除元素也是可以的
e.g x[2:] = list('xxxx')  
e.g x[2:] = []  
####2.3.3 列表方法  
方法是一个与某些对象有紧密联系的函数，对象可能是列表、数字，也可能是字符串或者其他类型的对象，方法可通过【对象.方法(参数)】进行调用。  
1.append  
此方法用于在列表末尾追加新的对象  
2.count  
count方法统计某个元素在列表中出现的次数  
3.extend  
extend方法可以在列表的末尾一次性追加另一个序列中的多个值，即可以用新列表扩展原有的列表。extend方法修改了被扩展的序列，原始的连接操作则不然，它会返回一个全新的列表。  
e.g  
a = [1, 2, 3]  
b = [4, 5, 6]  
a.extend(b)
a = [1, 2, 3, 4, 5, 6]  
4.index  
index方法用于从列表中找到某个值第一个匹配项的索引位置。  
e.g  
knnights = ['we', 'are', 'the', 'knights', 'who', 'say', 'ni']  
knights.index('who')  
4  
5.insert  
insert方法用于将对象插入到列表中。
e.g x.insert(索引号，内容)  
6.pop  
pop方法会移除列表中的一个元素（默认是最后一个元素），并且返回该元素的值。  
e.g x.pop()
PS：pop方法是唯一一个既能修改列表又返回元素值（除了None）的列表方法。  
使用pop方法可以实现一种常见的数据结构--栈。后进先出。  
7.remove  
remove用于移除列表中某个值的第一个匹配项。  
e.g x.remove('be')  
8.reverse  
reverse方法将列表中的元素反向存放。同时将反向列表存入原列表中。    
e.g x.reverse()  
9.sort  
sort方法用于在原位置对列表进行排序，同时会改变原来的列表，从而让其中的元素能按一定的顺序排列。  
e.g x.sort()  
10.高级排序  
如果希望元素能按照特定的方式进行排序，那么可以通过compare(x,y)的形式自定义比较函数。compare(x,y)函数会在x＜y事返回负数，在x＞y时返回正数，在x＝y时返回0。定义好函数之后，就可以提供给sort方法作为参数了。  
内建函数cmp提供了比较函数的默认实现方式：  
e.g cmp(42,32) = 1  
sort方法还有另外两个可选的参数--key和reverse。若使用这两个参数，则需要通过名字来指定。  
参数key在使用的过程中必须提供一个在排序过程中使用的函数，然后所有元素根据键来排序。  
e.g x.sort(key=len)  
参数reverse是通过简单的布尔值来指定列表是否要进行反向排序。  
e.g x.reverse(reverse=True)【从大到小排序】
### 2.4 元组：不可变序列  
元组与列表一样，也是一种序列，唯一不同的是元组不能修改。创建元组的语法很简单，如果你用逗号分隔了一些值，那你就自动创建的元组。  
元组通过(1,2,3)表示；空元组用空括号表示。  
#### 2.4.1 tuple函数  
tuple函数的功能与list函数基本上是一样的，以一个序列作为参数并把它转换为元组。若参数就是元组，则返回该参数。  
#### 2.4.2 基本元组操作  
除了创建和访问元组之外，没有太多其他操作。可以参照其他类型的序列来实现。  
#### 2.4.3 那么，意义何在  
元组之所以不可替代，主要是因为以下俩条原因：  
元组可以在映射中当作键使用，而列表不可以；  
元组作为很多内建函数和方法的返回值存在；
### 2.5 小结  
## 第3章 使用字符串  
### 3.1 基本字符串操作  
所有标准的序列操作（索引、分片、乘法、判断成员资格、求长度、取最大值和最小值）对字符串同样适用；但是字符串是不可变的。
### 3.2 字符串格式化：精简版  
字符串格式化使用字符串格式化操作符即百分号%实现，在%的左侧放置一个字符串，而右侧则放置希望格式化的值。  
PS：%也可用作模运算（求余数）操作符  
格式化字符串的%s部分称为转换说明符，标记了需要插入转换值的位置。s表示会被格式化的字符串。  
格式化%f是浮点型转换说明符，一个句点再加上一个希望保留的小数位数。  
e.g %.2f
### 3.3 字符串格式化：完整版 
格式化操作符的右操作符可以使任何东西，如果是元组或者映射类型（如字典），那么字符串格式化会有所不同。  
如果右操作数是元组的话，则其中的每一个元素都会被单独格式化，每个值都需要一个对应的转换说明符。 
PS：如果需要转换的元组作为转换表达式的一部分存在，那么必须将它用圆括号括起来，以避免出错。  
e.g '%s plus %s equals %s' % (1, 1, 2)  
基本的转换说明符包括以下几个部分：  
1.%字符：标记转换说明符的开始；  
2.转换标志（可选）：-表示左对齐；+表示在转换至之前要加上正负号；‘’空白字符表示正数之前保留空格；0表示转换值若位数不够则用0填充；  
3.最小字段宽度（可选）：转换后的字符串至少应该具有该指定的宽度；  
4.点(.)后跟随精度值（可选）：如果转换的是实数，精度值就表示出现在小数点后的位数。如果转换的是字符串，那么精度值则代表最大字段宽度。如果是*，那么精度值将会从元组中读出；  
5.转换类型：表示转换类型，详情见下表  
d,i：带符号的十进制整数  
o：不带符号的八进制  
u：不带符号的十进制  
x：不带符号的十六进制（小写）  
X：不带符号的十六进制（大写）  
e：科学计数法表示的浮点数（小写）  
E：科学计数法表示的浮点数（大写）  
f,F：十进制浮点数  
C：单字符（接受整数或者单字符字符串）  
r：字符串（使用repr转换任意Python对象）  
s：字符串（使用str转换任意Python对象）  
#### 3.3.1 简单转换  
简单转换只需要写出转换类型即%f  
#### 3.3.2 字符宽度和精度  
转换说明符可以包括字段宽度和精度。字段宽度是转换后的值所保留的最小字符个数，精度（对于数字而言）则是结果中应该包含的小数位数；（对于字符串转换来说）是转换后的值所能包含的最大字符个数。  
表示方法为【%字段宽度.精度转换类型】  
#### 3.3.3 符号、对齐和0填充  
在字段宽度和精度值之前还可以放置一个“标表”，标表可以使0、-、+或空格。  
0：表示数字会用0进行填充  
-：用来左对齐数值  
+：不管是正数还是负数都标示出符号
### 3.4 字符串方法 
#### 3.4.1 find  
find方法可以在一个较长的字符串中查找子字符串。它返回子串所在位置的最左端索引；如果未找到则返回-1。  
PS：成员资格判断in操作符只能用来查找字符串中的单个字符  
同时，find方法接受可选的起始点和结束点参数  
e.g s.find('子串',1,20) [1，20）  
#### 3.4.2 join  
join方法是非常重要的字符串方法，它是split方法的逆方法，用来在队列中添加元素。  
e.g s1.join(s2)  
将s1的内容插入到s2中
#### 3.4.3 lower  
lower返回字符串的小写字母版。  
在编写“不区分大小写”的代码时，会用到这个方法  
e.g s.lower()
#### 3.4.4 replace  
replace方法返回某字符串的所有匹配项军备替换之后得到的字符串。  
e.g s.replace('原始字符子串'，‘新字符子串’)
#### 3.4.5 split  
split是非常重要的字符串方法，它是join的逆方法，用来将字符串分割成序列。  
PS：如果不提供隔断符，默认使用空格作为分隔符  
#### 3.4.6 strip  
strip方法返回去除两侧（不包括内部）空格的字符串。  
PS：strip方法和lower方法一起使用的话就可以很方便的对比输入和存储的值。  
e.g s.strip()  
#### 3.4.7 translate  
translate用来替换字符串中的某些部分，但只处理单个字符。其优势在于可以同时进行多个替换。  
？？？？？？？？？？？？？？？？？？？？
### 3.5 小结  
## 第4章 字典：当索引不好引用时
通过名字引用值的数据结构是映射（mapping）。  
字典是Python中唯一内建的映射类型。字典中的值没有特殊的顺序，但都存储在一个特定的键里，键可以是数字、字符串甚至是元组。
### 4.1 字典的使用  
字典这个名称已经给出了有关这个数据结构功能的一些提示，一方面，对于普通的书来说，都是按照从头到尾的顺序进行阅读；另一方面也可以快速翻到某一页。  
Python中的字典进行了构造，从而可以轻松查到某个特定的词语，而找到它的定义。  
某些情况下，字典比列表更适用：  
表征游戏棋盘的状态，每个键都是由坐标值组成的元组；  
存储文件修改次数，用文件名作为键；  
数字电话/地址薄
### 4.2 创建和使用字典  
字典是由多的键及与其对应的值构成（称之为键值对）。  
键和值之间用英文冒号隔开；  
键值对之间用英文逗号隔开；  
整个字典用大括号表示；  
空字典用{}表示；  
PS：字典中的键是唯一的，但值不是。  
#### 4.2.1 dict函数  
可以用dict函数，通过其他映射（如字典）或者（键、值）这样的序列来建立字典；  
dict函数也可以通过关键字参数来创建字典  
#### 4.2.2 基本字典操作  
字典的基本行为在很多方面和序列相似：  
len(d)		返回d中键值对的数量；  
d[k]			返回键k对应的值；  
d[k]=v		将v赋值给d中的k键；  
del d[k]		删除键为k的项；
k in d		检查d中是否有k键；  
字典和列表的区别：  
键类型：字典的键不一定为整型数据；  
自动添加：即使那个键起初不在字典中存在，也可以为它分配一个值，这样字典就会建立新的项；  
成员资格：表达式k in d查找的是键，表达式v in l查找的是值；
PS：键可以为任何不可变类型
#### 4.2.3 字典的格式化字符串  
在每个转换说明符中%的后面可以加上键，后面再跟上其他说明元素  
#### 4.2.4 字典方法  
1.clear  
用来清楚字典中的所有的项，无返回值（或者说返回none）  
2.copy  
返回一个具有相同键值对的新字典（浅复制shallow copy）  
3.fromkeys  
使用给定的键建立新的字典，每个键默认对应的值为none  
4.get  
类似于字典查询，返回对应的值；若不存在则返回None  
5.has_key  
检查字典中是否含有给出的键  
6.items和iteritems  
items方法将所有的字典项以列表方式返回；  
iteritems方法大致相同，但是会返回一个迭代器对象而不是列表；  
7.keys和iterkeys  
keys方法将字典中的键以列表形式返回；  
而iterkeys则返回针对键的迭代器；  
8.pop  
pop方法用来获得对应于给定键的值，然后将这个键值对从字典中移除；  
9.popitem  
popitem方法类似于list.pop，popitem弹出随机的项；  
10.setdefault  
类似于get方法，能够获得与给定键相关联的值；  
11.update  
可利用一个字典去更新另外一个字典；  
12.values和itervalues  
values方法以列表的形式返回字典中的值；  
itervalues返回值的迭代器；
### 4.3 小结
## 第5章 条件、循环和其他语句
### 5.1 print和import的更多信息  
#### 5.1.1 使用逗号输出  
print可打印多个表达式，只要将表达式用逗号隔开即可；  
想要同时输出文本和变量值，却又不希望使用字符串格式化的话，这个特性就非常有用了  
#### 5.1.2 把某件事作为另一件事导入  
从模块导入函数的时候可以使用  
import 模块名  
或  
from 模块名 import 函数名1, 函数名2  
或  
from 模块名 import *  
或  
import 模块名 as 模块别名  
或  
from 模块名 import 函数名 as 函数别名
### 5.2 赋值魔法  
就算是不起眼的赋值语句也有一些特殊的技巧
#### 5.2.1 序列解包  
多个赋值操作可以同时进行  
e.g x, y, z = 1, 2, 3  
这里所做的事情叫做序列解包或可选迭代解包--将多个值的序列解开，然后放到变量的序列中  
#### 5.2.2 链式赋值  
将同一个值赋给多个变量的捷径  
e.g x = y = 1  
作用同下  
x = 1  
x = y  
#### 5.2.3 增量赋值  
将表达式运算符放置在赋值运算符的左边，我们称之为增量赋值  
e.g x += 1
### 5.3 语句块：缩排的乐趣  
语句块是在条件为真（条件语句）时执行或者执行多次（循环语句）的一组语句。  
在代码前放置空格来缩进语句即可创建语句块。  
PS：使用tab字符也可以缩进语句块  
同一个语句块中的每行应该缩进同样的量；  
在Python中冒号(:)标识语句块的开始
### 5.4 条件和条件语句  
到目前为止，程序都是一条一条语句顺序执行的，在这一节会介绍让程序选择是否执行语句块的方法。  
#### 5.4.1 这就是布尔变量的作用  
真值也叫做布尔值；  
如下的值在作为布尔表达式的时候，会被解释器看作假（false）：  
False None 0 “” () [] {}  
其他的一切都被解释为真，包括特殊值True  
‘标准的’真值为True和False，是1和0的一种‘华丽’的说法，作用是相同的  
#### 5.4.2 条件执行和if语句  
真值可以联合使用；  
在if语句中，如果条件判断为真，那么后面的语句块会被执行，否则，后面的语句块不会被执行  
#### 5.4.3 else子句  
else子句是if语句的一部分，可有可无；  
在if条件判断为假时，执行else子句  
#### 5.4.4 elif子句  
elif是else if的缩写，在检查多个条件时适用  
#### 5.4.5 嵌套代码块  
if语句里面可以嵌套使用if语句  
#### 5.4.6 更复杂的条件  
1.比较运算符  
用在条件判断中最基本的运算符就是比较运算符了，用来比较其他对象  
在Python中比较运算符和赋值运算一样是可以连接的  
2.相等运算符  
== 相等运算符  
3.is：同一性运算符  
is运算符是判定同一性而不是相等性  
4.in：成员资格运算符  
5.字符串和序列比较  
字符串可以按照字母顺序排列进行比较  
6.布尔运算符  
and  
not  
or  
#### 5.4.7 断言  
断言使用assert语句表示；  
在需要确保程序中某个条件一定为真才能让程序正常工作的时候，assert语句就非常有用了  
### 5.5 循环  
条件为真或者假时，重复执行很多次；  
#### 5.5.1 while循环  
while语句非常灵活，它可以在任何条件为真的情况下重复执行一个代码块  
x = 1  
total = 0  
while x <= 100:  
    print(x)  
    total += x  
    x += 1  
print(total)  
#### 5.5.2 for循环  
当需要针对可迭代对象执行代码块时，需要使用for循环  
words = [1, 2, 3, 4, 5, 6, 7]  
for word in words:  
    print(word)  
迭代（循环的另一种叫法）某范围的数字是很常见的，所以有个内建的范围函数很好用  
e.g range(0,10)  
Range函数的工作方式类似于分片，包含下限，不包含上限；即左闭右开  
xrange函数的循环行为类似于range函数，二者区别如下：  
range函数生成一个序列  
xrange函数一次只创建一个数，当迭代一个巨大的序列时xrange函数会更高效  
#### 5.5.3 循环遍历字典元素  
一个简单的for循环就能遍历字典中的所有键，就像处理序列一样  
for循环的一大好处就是可以循环中使用序列解包  
#### 5.5.4 一些迭代工具  
1.并行迭代  
程序可以同时进行两个迭代  
内建函数zip函数可以用来进行并行迭代，可以把两个序列压缩在一起，然后返回一个元组的列表；  
zip函数可以应付不等长的序列，当最短的序列用完的时候就会停止  
2.编号迭代  
3.翻转和排序迭代  
函数reversed和sorted，同列表的reverse和sort方法类似，但作用域任何序列和可迭代对象上，不是原地修改对象，而是返回翻转或排序后的版本  
#### 5.5.5 跳出循环  
一般来说，循环会一直执行到条件为假，或者序列元素用完时，但是有些时候可能会提前中断一个循环，进行新的迭代，或者仅仅就是想结束循环。  
1.break  
跳出循环可以使用break语句  
2.continue  
continue语句比break语句用的要少的多，它会让当前迭代结束，跳到下一轮循环的开始，它最基本的意思是跳过剩余的循环体，但是不结束循环。  
当循环体很大而且很复杂的时候，这会很有用  
3.while True/break语句  
#### 5.5.6 循环中的else语句  

### 5.6 列表推导式——轻量级循环  
列表推导式是利用其他列表创建新列表的一种方法，工作方式类似于for循环。  
e.g [x * x for x in range(10) if x % 3 ==0]  
### 5.7 三人行  
做为本章的结束，让我们走马观花的看另外3个pass、del和exec。  
#### 5.7.1 什么都没发生  
有的时候，程序什么事情都不用做，这个时候就可以用pass语句了  
#### 5.7.2 使用del删除  
一般来说，Python会删除那些不再使用的对象；  
使用del语句，会删除一个对象的引用，也会移除那个名字本身  
#### 5.7.3 使用exec和eval执行和求值字符串  
1.exec  
执行一个字符串的语句是exec  
2.eval  
eval类似于exec的内建函数
### 5.8 小结
## 第6章 抽象  
本章介绍如何将语句组织成函数，这样只需要告诉计算机一次。有了函数之后就不必反反复复向计算机传递同样的具体指令了，本章还会详细介绍参数（parameter）和作用域（scope）的概念，以及递归的概念及其在程序中的用途。
### 6.1 懒惰即美德  
目前为止，我们编写的程序都很小，如果想要编写大型程序，就会遇到麻烦；  
想象以下，如果我们在一个地方写代码，在另一个地方也需要用到这些代码。这时会发生什么？   
真正的程序员会让自己的程序抽象一些。名为fibs的函数被创建，然后再需要计算斐波那契数列的地方调用fibs函数即可。
### 6.2 抽象与结构  
抽象可以节省很多工作，实际上它的作用还要更大。  
### 6.3 创建函数  
函数是可以调用（包含参数），它执行某种行为并且返回一个值。  
使用def语句定义函数；  
return语句非常重要，是用于从函数中返回值的。  
#### 6.3.1 记录函数  
为了使函数更容易让人理解，可以在函数的对应位置加上相应的注释；  
注释以#开头；  
另外一个方式就是直接写上字符串，在def语句后面及模块或者类的开头写上字符串，我们称之为文档字符串；  
内建的help函数非常有用，在交互式解释器中使用它，就可以得到关于函数，包括它的文档字符串的信息  
#### 6.3.2 并非真正函数的函数  
数字意义的函数，总在计算其参数后返回点什么；但是Python的某些函数却并不返回任何东西。
### 6.4 参数魔法  
函数使用起来很简单，创建起来也并不复杂，但是函数参数的用法就有些不可思议了。  
#### 6.4.1 值从哪里来  
编写函数只是给程序需要的部分提供服务，能保证函数在提供给可接受参数的时候正常工作，参数错误的话会导致失败（一般来说，这时候要用到断言和异常）；  
写在def语句中函数名后面的变量通常叫做函数的形式参数；  
调用函数时提供的值是实际参数，或称之为参数  
#### 6.4.2 我能改变参数吗  
在函数内为参数赋值不会改变外部任何变量的值；  
参数存储在局部作用域内;  
字符串、数字、元组是不可变的，所以当上述数据类型做参数时，参数无法被修改；  
当可变数据结构做参数时，参数会被修改；  
当两个变量同时引用一个列表时，它们确是同时引用一个列表；  
如果想避免出现类似状况，可以复制一个列表的副本；当在序列中做切片的时候，返回的切片总是一个副本  
1.为什么我想要修改参数  
使用函数改变数据结构是将程序抽象化的好方法；  
抽象的要点就是隐藏更新时的繁琐细节  
????????????????????  
2.如果我的参数不可变呢  
函数只能修改参数对象本身；  
应该从函数中返回所有你需要的值；  
真想改变参数的话，可以将值放置到列表中  
#### 6.4.3 关键字参数和默认值  
目前为止我们所使用的参数都叫做位置参数。本节中引入的这个功能可以回避位置问题。  
有些时候，参数的顺序是很难记住的，为了让事情简单些，可以提供参数的名字。这类使用参数名提供的参数叫做关键字参数，它的主要作用在于可以明确每个参数的作用。  
当参数具有默认值的时候，调用的时候就不用提供参数了。  
#### 6.4.4 收集参数  
> def print_param(*params):  
  
*params，星号将所有值放置在同一个元组中；我们称之为收集其余的位置参数；  
收集其余的位置参数可以与普通参数同时使用；  
我们需要另外一个能处理关键字参数的“收集”操作，表示方法如下  
> def print_params(**param)  
返回字典  
#### 6.4.5 反转过程  
不是收集参数，二十分配它们在运算符号的两端  
#### 6.4.6 练习使用参数  

### 6.5 作用域  
变量和所对应的值是个‘不可见’的字典，这类不可见字典叫做命名空间或者作用域；  
除了全局作用域外，每个函数调用都会创建一个新的作用域；  
局部变量：函数内的变量；  
全局变量：函数外的变量；
### 6.6 递归  
函数对函数本身进行的调用，我们称之为递归；  
无穷递归：类似于while true开始的无穷循环；  
有用的递归函数包含以下几个部分：  
1.当函数直接返回值时有基本实例（最小可能性问题）  
2.递归实例，包括一个或者多个问题最小部分的递归调用  
#### 6.6.1 两个经典：阶乘和幂  
#### 6.6.2 另外一个经典：二元查找  

### 6.7 小结
## 第7章 更加抽象  
Python的核心概念，Python是面向对象的语言。
### 7.1 对象的魔力  
面向对象设计中的术语对象（object）可以看做数据以及由一系列可以存取、操作这些数据的方法所组成的集合。  
对象最重要的优点包括以下几个方面：  
多态：意味着可以对不同类的对象使用同样的操作  
封装：对外部世界隐藏对象的工作细节  
继承：以普通的类为基础建立专门的类对象  
#### 7.1.1 多态  
术语多态来自于希腊语，意思是“有多种形式”。  
多态意味着就算不知道变量所引用的对象类型是什么，还是能对它进行操作，而它会根据对象（或类）类型的不同而表现出不同的行为  
1.多态和方法  
程序得到一个对象，不知道它是怎么实现的，它可能有很多种形状，你要做的就是询问价格，这就够了。  
> object.getPrice() 
 
绑定到对象特性上面的函数称为方法  
2.多态的多种形式  
任何不知道对象到底是什么类型，但是又要对对象做点什么的时候，都会用到多态  
> def add(x, y):
> return x + y  

PS：本例仅支持同类的加法  
#### 7.1.2 封装  
封装是对全局作用域中其他区域隐藏多余信息的原则。使用对象而不用知道其内部细节。  
和多态比较类似。因为它们都是抽象原则---会帮助处理程序组件而不用过多关心多余细节，就像函数做的一样。  
封装不等同于多态。  
多态可以让用户对于不知道是什么类（或类型）的对象进行方法调用；  
封装是可以不用关心对象是如何构建的而直接进行使用  
对象的状态由它的特性来描述，对象的方法可以改变它的特性。  
#### 7.1.3 继承  
继承是另外一个懒惰的行为。  
在两个类具有相似特性，但是又不完全一样的时候，需要用到继承。
### 7.2 类和类型  
#### 7.2.1 类到底是什么  
类可以被认为是种类或者类型的同义词。类是一种对象，所有的对象都属于某一个类，称为类的实例。  
当一个对象所属的类是另外一个对象所属类的子集时，前者就被称为后者的子类。  
鸟		百灵鸟类		百灵鸟  
PS：Python中习惯用单数名词表示类，首字母大写，例如Bird。  
在面向对象程序设计中，子类的关系是隐式的，因为一个类的定义取决于它所支持的方法。类的所有实例都会包含这些方法，所以所有子类的所有实例都有这些方法，定义子类只是个定义更多的方法的过程。  
#### 7.2.2 创建自己的类  
在调用setname和greet函数时，foo自动将自己作为第一个参数传入函数中，因此形象地命名为self，表示对象自身。若无self，成员方法就没法访问他们要对其特性进行操作的对象本身了。  
#### 7.2.3 特性、函数和方法  
self参数事实上正是方法和函数的区别。  
方法（绑定方法）：将它们的第一个参数绑定到所属的实例上，因此这个参数可以不必提供。  
#### 7.2.4 类的命名空间  
下面两个语句几乎等价：  
def foo(x):		return x * x  
foo = lambda x: x * x  
以上两种表达方式均返回参数的平方函数，而且均将foo绑定到函数上。  
所有位于class语句中的代码都在特殊的命名空间中执行--类命名空间。  
#### 7.2.5 指定超类  
子类可以扩展超类的定义，将其他类名写在class语句后的圆括号内可以指定超类。超类具有如下特点：  
这里用提供新定义的方式重写了Fileter的init定义  
filter方法的定义是从filter类中继承的  
#### 7.2.6 调查继承  
如果想要查看一个类是否是另一个的子类，可以使用内建issubclass函数来检查；  如果想要知道已知类的基类（们），可以直接使用它的特殊特性__base__；  
issubclass方法还是检查对象是否是一个类的实例；  
#### 7.2.7 多个超类  
子类可以不做任何事，它从自己的超类继承所有的行为。  
一个子类从两个及以上的类继承方法，这种行为我们称之为多重继承。  
#### 7.2.8 接口和内省  
‘接口’的概念和多态有关。在处理多态形象时，只要关心它的接口（或协议）即可--即公开的方法和特性。
### 7.3 一些关于面向对象设计的思考  
将属于一类的对象放在一起。如果一个函数操纵一个全局变量。让其他实例管理自己的状态。  
不要让对象过于亲密。方法应该只关心自己实例的特性。让其他实例管理自己的状态。  
要小心继承，尤其是多重继承。
简单就好，让你的方法巧。尽量将代码行数控制在一页或者一屏之内。  
当你需要考虑什么类以及类要有什么方法时，应该尝试下面的方法：  
（1）写下问题的描述，把所有名词、动词和形容词加下划线  
（2）对于所有名词，用作可能的类  
（3）对于所有动词，用作可能的方法  
（4）对于所有形容词，用作可能的特性  
（5）把所有的方法和特性分配到类  
有了面向对象模型的草图了，还可以考虑类和对象之间的关系；  
（1）写下一系列的使用实例--即程序应用的场景，包括所有的功能；  
（2）一步步考虑每个使用实例，保证模型包括所有需要的东西
### 7.4 总结
## 第8章 异常
### 8.1 什么是异常
### 8.2 按自己的方式出错
### 8.3 捕捉异常
### 8.4 不止一个except子句
### 8.5 用一个块捕捉两个异常
### 8.6 捕捉对象
### 8.7 真正的全捕捉
### 8.8 万事大吉
### 8.9 最后...
### 8.10 异常和函数
### 8.11 异常之禅
### 8.12 小结
## 第9章 魔法方法、属性和迭代器
### 9.1 准备工作
### 9.2 构造方法
### 9.3 成员访问
### 9.4 更多魔力
### 9.5 属性
### 9.6 迭代器
### 9.7 生成器
### 9.8 八皇后问题
### 9.9 小结
## 第10章 充电时刻
### 10.1 模块
### 10.2 探究模块
### 10.3 标准库：一些最爱
### 10.4 小结
## 第11章 文件和素材
### 11.1 打开文件
### 11.2 基本文件方法
### 11.3 对文件内容进行迭代
### 11.4 小结
## 第12章 图形用户界面
### 12.1 丰富的平台
### 12.2 下载和安装wxPython
### 12.3 创建示例GUI应用程序
### 12.4 但是我宁愿用
### 12.5 小结
## 第13章 数据库支持
### 13.1 Python数据库API
### 13.2 SQLite和PySQLite
### 13.3 小结
## 第14章 网络编程
### 14.1 少数几个网路设计模块
### 14.2 SocketServer和它的朋友们
### 14.3 多连接
### 14.4 Twisted
### 14.5 小结
## 第15章 Python和万维网
### 15.1 屏幕抓取
### 15.2 使用GUI创建动态网页
### 15.3 更进一步：mod_python
### 15.4 网路应用程序框架
### 15.5 Web服务：正确分析
### 15.6 小结
## 第16章 测试
### 16.1 先测试，后编码
### 16.2 测试工具
### 16.3 单元测试以外的内容
### 16.4 小结
## 第17章 扩展Python
### 17.1 考虑哪个更重要
### 17.2 非常简单的途径JPython和IronPython
### 17.3 编写C语言扩展
### 17.4 小结
## 第18章 程序打包
### 18.1 Distutils基础
### 18.2 打包
### 18.3 编译扩展
### 18.4 使用py2exe创建可执行程序
### 18.5 小结
## 第19章 好玩的编程
### 19.1 为什么要好玩
### 19.2 程序设计的柔术
### 19.3 原型设计
### 19.4 配置
### 19.5 日志记录
### 19.6 如果还没烦
### 19.7 如果还想学
### 19.8 小结
## 第20章 项目1：即时标记
### 20.1 问题是什么
### 20.2 有用的工具
### 20.3 准备工作
### 20.4 初次实现
### 20.5 再次实现
### 20.6 进一步探索
## 第21章 项目2：画幅好画
### 21.1 问题
### 21.2 有用的工具
### 21.3 准备工作
### 21.4 初次实现
### 21.5 再次实现
### 21.6 进一步探索
## 第22章 项目3：万能的XML
### 22.1 问题
### 22.2 有用的工具
### 22.3 准备工作
### 22.4 初次实现
### 22.5 再次实现
### 22.6 进一步探索
## 第23章：项目4：新闻聚合
### 23.1 问题
### 23.2 有用的工具
### 23.3 准备工作
### 23.4 初次实现
### 23.5 再次实现
### 23.6 进一步探索
## 第24章 项目5：虚拟茶话会
### 24.1 问题
### 24.2 有用的工具
### 24.3 准备工作
### 24.4 初次实现
### 24.5 再次实现
### 24.6 进一步探索
## 第25章 项目6：使用CGI进行远程编辑
### 25.1 问题
### 25.2 有用的工具
### 25.3 准备工作
### 25.4 初次实现
### 25.5 再次实现
### 25.6 进一步探索
## 第26章 项目7：自定义电子公告板
### 26.1 问题
### 26.2 有用的工具
### 26.3 准备工作
### 26.4 初次实现
### 26.5 再次实现
### 26.6 进一步探索
## 第27章 项目8：使用XML-RPC进行文件共享
### 27.1 问题
### 27.2 有用的工具
### 27.3 准备工作
### 27.4 初次实现
### 27.5 再次实现
### 27.6 进一步探索
## 第28章 项目9：文件共享2——GUI版本
### 28.1 问题
### 28.2 有用的工具
### 28.3 准备工作
### 28.4 初次实现
### 28.5 再次实现
### 28.6 进一步探索
## 第29章 项目10：DIY街机游戏
### 29.1 问题
### 29.2 有用的工具
### 29.3 准备工作
### 29.4 初次实现
### 29.5 再次实现
### 29.6 进一步探索


